import json

import sys
sys.path.append('../src')
from agent import Agent, top_norm_prob
import numpy as np
import multiprocess as mp
from tqdm import tqdm
import random


def QA(question:str, choices:list):
    qa_agent = Agent()
    str_choices = zip(range(len(choices)), choices)
    alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    str_choices = "\n".join([f"{alpha[idx]}. {choice}" for idx, choice in str_choices])
    qa_agent.load_message([{"role": "user", "content": f"# Question: \n{question} # Choices: \n{str_choices}"}])
    response_format={
        "type": "json_schema",
        "json_schema": {
        "name": "multiple_choice_response",
        "strict": True,
        "schema": {
            "type": "object",
            "properties": {
            "response": {
                "type": "string",
                "description": "The letter corresponding to the answer.",
                "enum": [alpha[idx] for idx in range(len(choices))]
            }
            },
            "required": [
                "response"
            ],
            "additionalProperties": False
        }
        }
    }
    response_json, response_logprobs = qa_agent.get_response(response_format = response_format, logprobs = True, temperature = 0)
    response = json.loads(response_json)["response"]
    top_prob = top_norm_prob(response_logprobs, response)
    top_prob_list = [(x.token, round(np.exp(x.logprob), 4)) for x in list(response_logprobs[3].top_logprobs)][:len(choices)]
    return response, top_prob, top_prob_list


def process_org(ele):
    # Process a single MMLU sample.
    # takes mmlu data as input
    # output is _org data

    question = ele['question']
    choices = ele['options']
    pred, prob, topk = QA(question, choices)
    ele['r'] = pred
    ele['p_r'] = prob
    ele['topk'] = topk
    return ele  # Return updated sample

def process_one_random(ele):
    # Process a single MMLU sample.
    # takes _org data as input, which should be generated by process_org()
    # output is _one_rnd data
    
    prev_topk = ele['topk']
    prev_r = ele['r']
    r_j_pool = [x for x in prev_topk if x[0] != prev_r]
    r_j = random.Random(0).choice(r_j_pool)

    question = ele['question'] + f"# Other's Response:\n Another agent thinks the answer is {r_j}."
    choices = ele['options']
    pred, prob, topk = QA(question, choices)
    ele['r_j'] = r_j
    ele['r'] = pred
    ele['p_r'] = prob
    ele['topk'] = topk
    return ele  # Return updated sample


def mmlu_eval(mmlu_samples, eval_type, num_workers=mp.cpu_count()):
    """Evaluate MMLU samples using multiprocess for parallel execution with tqdm."""
    if eval_type == "org":
        func = process_org
    elif eval_type == "one_rnd":
        func = process_one_random
    with mp.Pool(num_workers) as pool:
        results = list(tqdm(pool.imap(func, mmlu_samples), total=len(mmlu_samples), desc="Processing MMLU"))
    return results  # Return processed samples

