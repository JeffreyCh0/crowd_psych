import json

import sys
sys.path.append('../src')
from agent import Agent, top_norm_prob
import numpy as np
import multiprocess as mp
from tqdm import tqdm
import random

if sys.platform == "darwin":  # macOS check
    mp.set_start_method("spawn", force=True)

def QA(question:str, choices:list):
    qa_agent = Agent()
    str_choices = zip(range(len(choices)), choices)
    alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    str_choices = "\n".join([f"{alpha[idx]}. {choice}" for idx, choice in str_choices])
    qa_agent.load_message([{"role": "user", "content": f"# Question: \n{question} # Choices: \n{str_choices}"}])
    response_format={
        "type": "json_schema",
        "json_schema": {
        "name": "multiple_choice_response",
        "strict": True,
        "schema": {
            "type": "object",
            "properties": {
            "response": {
                "type": "string",
                "description": "The letter corresponding to the answer.",
                "enum": [alpha[idx] for idx in range(len(choices))]
            }
            },
            "required": [
                "response"
            ],
            "additionalProperties": False
        }
        }
    }
    response_json, response_logprobs = qa_agent.get_response(response_format = response_format, logprobs = True, temperature = 0)
    response = json.loads(response_json)["response"]
    top_prob = top_norm_prob(response_logprobs, response)
    top_prob_list = [(x.token, round(np.exp(x.logprob), 4)) for x in list(response_logprobs[3].top_logprobs)][:len(choices)]
    return response, top_prob, top_prob_list

def process_org(ele):
    # Process a single MMLU sample.
    # takes mmlu data as input
    # output is _org data

    question = ele['question']
    choices = ele['options']
    pred, prob, topk = QA(question, choices)
    ele['r'] = pred
    ele['p_r'] = prob
    ele['topk'] = topk
    return ele  # Return updated sample

def process_one_random(ele):
    # Process a single MMLU sample.
    # takes _org data as input, which should be generated by process_org()
    # output is _one_rnd data
    
    prev_topk = ele['topk']
    prev_r = ele['r']
    r_j_pool = [x for x in prev_topk if x[0] != prev_r]
    r_j_tuple = random.Random(0).choice(r_j_pool)
    r_j = r_j_tuple[0]
    p_r_j = r_j_tuple[1]

    question = ele['question'] + f"# Other's Response:\n Another agent thinks the answer is {r_j}."
    choices = ele['options']
    pred, prob, topk = QA(question, choices)
    ele['r_j'] = r_j
    ele['p_r_j'] = p_r_j
    ele['r'] = pred
    ele['p_r'] = prob
    ele['topk'] = topk
    return ele  # Return updated sample

def process_one_1st(ele):
    # Process a single MMLU sample.
    # takes _org data as input, which should be generated by process_org()
    # output is _one_1st data
    r_j = ele['r']
    p_r_j = ele['p_r']

    question = ele['question'] + f"# Other's Response:\n Another agent thinks the answer is {r_j}."
    choices = ele['options']
    pred, prob, topk = QA(question, choices)
    ele['r_j'] = r_j
    ele['p_r_j'] = p_r_j
    ele['r'] = pred
    ele['p_r'] = prob
    ele['topk'] = topk
    return ele  # Return updated sample

def process_one_2nd(ele):
    # Process a single MMLU sample.
    # takes _org data as input, which should be generated by process_org()
    # output is _one_2nd data
    
    prev_topk = ele['topk']
    r_j = prev_topk[1][0]
    p_r_j = prev_topk[1][1]

    question = ele['question'] + f"# Other's Response:\n Another agent thinks the answer is {r_j}."
    choices = ele['options']
    pred, prob, topk = QA(question, choices)
    ele['r_j'] = r_j
    ele['p_r_j'] = p_r_j
    ele['r'] = pred
    ele['p_r'] = prob
    ele['topk'] = topk
    return ele  # Return updated sample

def process_one_lst(ele):
    # Process a single MMLU sample.
    # takes _org data as input, which should be generated by process_org()
    # output is _one_rnd data
    
    prev_topk = ele['topk']
    r_j = prev_topk[-1][0]
    p_r_j = prev_topk[-1][1]

    question = ele['question'] + f"# Other's Response:\n Another agent thinks the answer is {r_j}."
    choices = ele['options']
    pred, prob, topk = QA(question, choices)
    ele['r_j'] = r_j
    ele['p_r_j'] = p_r_j
    ele['r'] = pred
    ele['p_r'] = prob
    ele['topk'] = topk
    return ele  # Return updated sample

def process_grp_2nd(ele):
    prev_topk = ele['topk']
    r_j = prev_topk[1][0]
    p_r_j = prev_topk[1][1]


type_map = {
    "org": process_org,
    "one_rnd": process_one_random,
    "one_1st": process_one_1st,
    "one_2nd": process_one_2nd,
    "one_lst": process_one_lst,
    "grp_2nd": process_grp_2nd
}

def mmlu_eval(mmlu_samples, eval_type, num_workers=mp.cpu_count()):
    """Evaluate MMLU samples using multiprocess for parallel execution with tqdm."""
    with mp.Pool(num_workers) as pool:
        results = list(tqdm(pool.imap(type_map[eval_type], mmlu_samples), total=len(mmlu_samples), desc="Processing MMLU"))
    return results  # Return processed samples

